[객체지향 프로그래밍의 특징] 추상화, 상속성, 다형성, 은닉성(캡슐화)
객체지향 프로그래밍(OOP)는 코드를 여러 독립적인 부픔들의 조합으로 보는 것이다.
1.추상화: 객체들의 공통특성(변수,함수)들을 묶어 표현
2.상속성: 상위클래스의 속성을 하위클래스에게도 부여할 수 있다.
3.다형성: 각 객체를 상황에 따라 다른 형태로 표현(ex.Character-EnemyCharacter-HordeEnemy)
4.은닉성: public,private 등을 사용해 접근을 한정

[메모리(힙과 스택)]
!스택은 정적메모리, 힙은 동적메모리를 저장한다.
스택은 컴파일 단계에서 크기가 결정됨. 그렇기에 동적으로 데이터를 할당할 수 없다.
힙은 사용자가 런타임 중에 사용하는 데이터 영역임. 동적으로 데이터할당 가능

힙은 메모리 높은 주소부터 할당되고, 스택은 메모리 낮은주소부터 할당된다.
이 중, 하나의 영역에서 데이터누수 등 오버플로우가 발생하여 다른 영역을 침범하는게 스택오버플로우 또는 힙오버플로우다.

[STL 컨테이너 특징과 원리]
-Array:
기본적인 배열과 흡사하며 컴파일링 단계에서 구조크기가 정해지기에, 동적으로 배열크기 변경이 불가능
stl의 특징인 iterator가 존재하고 size, at 등의 헬퍼함수들이 추가된 형태.

-Vector:
size와 capacity를 사용해 동적으로 배열크기를 조정.
단방향 구조이기에, 데이터 삽입을 뒤에서 해야지만 효과적이다.
맨앞이나 중앙에 넣으면 뒤에 애들을 모두 하나씩 밀어야해서 O(N) 시간이 걸린다.
또한 Sequence컨테이너이니까 임의접근이 가능하다. //v[3]

-List:
vector와 달리 메모리가 연속적으로 존재하지 않고 다음 메모리공간의 주소를 노드에 담고있는 구조로 이루어져있다.
노드간 연결구조라는 특성으로 인해 중간 삽입삭제가 용이하다.
단, 연속적으로 저장하지 않기에 노드를 검색(순회)하는 것은 오히려 vector보다 더 오래걸린다.

-Map:
Key값과 Value값을 갖는 이진트리 기반이다.
AVL(균형이진트리)의 구조로 인해 빠른 검색이 가능하다. O(logN)
단, 정렬구조를 이용하기에 매 삽입삭제마다 새로운 정렬이 일어남 -> 삽입/삭제가 빈번한 경우 비효율적이다.

-Unordered_map:
map과 다르게 정렬되지 않고, '해시함수'를 사용해 원소를 탐색한다. O(1) 접근이 굉장히 빠름
단, 운이 진짜 안좋으면 모든 value들이 하나의 bucket에 들어가고, 탐색에 n횟수가 소요될수도있다. //hash collision내용

*해시함수: 임의크기의 데이터를 고정된 크기 type의 데이터로 변환하는 함수.
=> 즉, (010-8456-7190,전영재)라고 많은 데이터를 써야하는 전화번호를 그저 1이라는 데이터로 바꿀수있다는것.
그리고 1이라는 bucket에 다시 010-8456-7190이라는 Key와 전영재라는 value로 보관하는 것이다. 
! 복잡한구조의 데이터를 hash(1,111)라는 단순한 데이터로 바꿔, 해당 bucket에 보관함
위 해쉬를 bucket에 담아주고 그 bucket의 모음을 hash table이라고 한다.

단, 데이터를 더욱 작은범위로 축소시키는 것이기에 hash끼리의 충돌이 생길수밖에 없다. //다른 키값이지만 연산후 같은 hash를 갖게됨
해당 방법을 해결하기 위한 방안들로 Seperate Chaining, Linear Probing 이 있다.
Chaining의 경우는 같은 bucket에 들어가는 hash들 끼리 ref를 사용해 연결시켜주는것. 그렇기에 나중에 key를 사용해 get을 하려하면,
key를 해쉬연산해주고 해당 bucket에서 찾아본다. 찾을때, 입력key와 저장된key가 맞는지 확인하고 다르다면 ref를 타고가 다음 저장key와 비교하는것.

LinearProbing은 해당 bucket이 이미 차있다면 다음 bucket에다 저장하는것임.
그리고 해쉬테이블이 다 차려하면 테이블 크기 자체를 늘려주는 방법이다. 구려보임.

-Set:
Value자체가 Key가 된다. 

[A* 길찾기]:	//시작점과 목적지만 알아도 좋은 길찾기 알고리즘
		//우선순위큐: 말그대로 앞뒤가 뚫린 큐인데, 우선순위 설정을 할당해주면 큐의 내용순서가 자동으로 정렬된다는것(완전이진트리 형태)
F=G+H 라는 점수매기기를 통해 최적경로를 찾아낸다. (F=점수,작을수록 좋다고 설정/ G=이동비용 / H=남은거리ㅡ작을수록좋다 설정,고정)

1) 예약(발견) 시스템 //인접한 경로 발견 및 예약
2) 뒤늦게 더좋은 경로 발견하면 -> 예외 처리 구현

1> '발견한 경로(좌표)'들을 우선순위 큐에 담는다->OpenList //우선순위큐에 담는 이유는 이게 나중에 최고노드를 순서대로 꺼내기 좋기때문이다.
2> 발견 노드중 최적f 노드의 부모를 현재노드로 설정하고, 현재노드를 close리스트에 담은뒤, 최적f 노드로 이동한다. //closed에 담아 이 구역에 대한 계산을 수행한 바가 있다는것을 기록
3> 새로운 노드에서 발견한 경로를 다시 Open리스트에 담는다. 위과정 반복.
4> 발견환 새로운노드가 도착지일 경우 알고리즘 종료
 이 과정 수행시 이동해온 경로노드 모두에 부모노드가 설정될 것이고, 이 부모를 따라가다 출발지가 나온다면 최적의 경로를 찾아낸 것이다.

//위 과정에서 f는 누적되어 계산되기에 중간에 잘못된 경로임을 알게되면(다음 최적f노드가 리스트내의 f보다 커짐),
우선순위 큐에 특성상 예전에 찾았던 경로중 어떤게 최고f인지 찾아내기 쉽다.

[FSM] Finite State Machine
유한한 갯수의 상태를 가지고 그중 하나를 취하는 형태
특정 조건하에 다른 상태로 전이된다.

주로 switch문을 사용하여 구현되며,
미칠듯한 if문의 스파게티코드를 해결하는데 용이하다.

장점=> 상태와 전이를 정확히 규정할 수 있으며, 반복된 코드를 줄이거나하여 가시성에 도움을 준다.

[BehaviorTree]
AI의 행동을 tree구조로 기술하여 행동트리, BehaviorTree라 불린다.
크게 root, Composite, Execution 노드로 구분되며 말그대로 루트,흐름제어,실행(task)노드를 의미한다.
-Composite노드 (합성물?)
1.Selector: 하나를 고르기위한 노드. 하나를 고르면(true) 끝. 자식 중 하나라도 True가 나오면 그즉시 Selector도 true를 반환한다.
2.Sequence: 순서대로 실행하기 위한노드. 하나라도 실패하면(fail) 끝. 자식 중 하나라도 false가 나오면 Sequence도 false를 반환한다.
//3.SimpleParallel: 메인테스크 하나를 전체트리와 함께 실행. (좌측이 메인이고, 우측이 메인과 동시에 돌아가는 부가기능 이라생각하자.)

-Execution노드
일반적으로 Action, UE에서는 Task라고 부른다.

//UE에서는 Decorator라 하여 컴포짓 또는 태스크에 붙어, 조건 분기를 정의하는 기능이 있다.

[Quadtree 공간분할]
공간데이터를 이진 데이터로 바꾸는 기법.
흑백데이터를 구분한다할때, 모든 영역이 흑,백이면 그대로 흑,백을 반환.
그러나 일부지역에 흑백이 섞여있다면 총 구역을 4등분한다. 그리고 각각의 구역이 흑인진 백인지 판별.
만약 해당 구역에서도 흑백이 섞였다면 그구역을 4등분. 위과정을 반복한다.
그러면 온전히 흑 또는 백으로 이루어진 구역으로 구성된 데이터를 표현할 수 있다.

[내적, 외적]
내적: 적이 앞,뒤에 있는지 확인하는데 유용(로아:백어택,헤드어택)
캐릭터의 forward벡터와 캐릭터-몹의 벡터를 unit벡터라 할때, 두 값을 내적해 나오는 값의 범위는 -1~1이다.
여기서 양수값이 나온다면 적이 캐릭터의 앞에 있다는 것이고, 음수가 나온다면 캐릭터의 뒤에 있다는 것이며, 정확히 0이라면 캐릭터 옆에 있다는 것이다.

또한 두벡터의 내적한값에 acos을 사용해 두 벡터사이의 각도를 알수있다. 이정보를 토대로 적의 시야각(Focus) 등에 활용해 캐릭터탐지에 사용할 수 있다.
단, 해당각도가 +45도인지-45도인지는 알수없기에(acos특성) 좌우 여부는 알 수 없다.

외적: 적이 좌/우에 있는지 확인하는데 유용하다.
내적과 같이 forward벡터와 unit벡터가 있을때, 두벡터를 xy평면에 투영한 후, 외적하면 양수 또는 음수의 결과가 나온다.
이를 통해서 적이 forward벡터 기준으로 좌측/우측에 있는지를 판별할 수 있다. //언리얼 기준, 왼손좌표계를 사용하기에 양=우측, 음=좌측

위 내적과 외적을 사용하면 캐릭터의 전후좌우에 대한 정보를 얻을수 있으며, 해당 결과를 응용해 방향별 Hit Animation 출력 같은 활용이 가능하다.

[게임엔진의 정의]
정의: 게임 소프트웨어의 구성에 필요한 구성 요소를 재사용할수 있게 만든 툴
그렇기에, 쉽게 접근가능한 인터페이스를 가지고 있고, 세부적효과까지 코딩할 필요가 없으며, 기능 개발의 단가와 복잡도를 줄여준다.
주요기능:플랫폼 추상화, 물리엔진, 쓰레딩

구성: 그래픽엔진(렌더링/애니메이션), 서버엔진, 사운드엔진, 입력처리엔진

[게임 루프]
'반복적으로 작동'함으로써 게임을 실행시킴. //게임은 결국 Update와 Render의 반복인 것처럼.

deltaTime을 사용하는이유:
각 프레임마다 코드를 표시하고 실행하는데 걸리는 시간은 기기마다 다를수 있다.
이러한 프레임의 차이는 각프레임마다 실행되는 코드계산에도 영향을 주며 다른 결과를 초래할 수 있다.
ex) 1프레임마다 이동하는 물체가 있다면, 60fps로 작동하는 컴에서는 30fps로 작동하는 컴보다 2배 빨리 움직이는것으로 보일것이다.
그렇기에 해당 로직에 deltaTime을 곱함으로써 프레임단위가 아닌 시간단위로 로직이 실행되게 만드는것이다.
